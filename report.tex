\documentclass[12pt,a4paper]{article}

% ============================================================================
% Packages
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[vietnamese]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{float}

\geometry{left=2.5cm, right=2cm, top=2.5cm, bottom=2.5cm}

% ============================================================================
% Code listing style
% ============================================================================
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{cstyle}{
    backgroundcolor=\color{codebg},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C,
    frame=single,
    rulecolor=\color{black!30},
    extendedchars=true,
    inputencoding=utf8,
    literate=
        {á}{{\'{a}}}1 {à}{{\`{a}}}1 {ả}{{\h{a}}}1 {ã}{{\~{a}}}1 {ạ}{{\d{a}}}1
        {ă}{{\u{a}}}1 {ắ}{{\'{\u{a}}}}1 {ằ}{{\`{\u{a}}}}1 {ẳ}{{\h{\u{a}}}}1 {ẵ}{{\~{\u{a}}}}1 {ặ}{{\d{\u{a}}}}1
        {â}{{\^{a}}}1 {ấ}{{\'{\^{a}}}}1 {ầ}{{\`{\^{a}}}}1 {ẩ}{{\h{\^{a}}}}1 {ẫ}{{\~{\^{a}}}}1 {ậ}{{\d{\^{a}}}}1
        {é}{{\'{e}}}1 {è}{{\`{e}}}1 {ẻ}{{\h{e}}}1 {ẽ}{{\~{e}}}1 {ẹ}{{\d{e}}}1
        {ê}{{\^{e}}}1 {ế}{{\'{\^{e}}}}1 {ề}{{\`{\^{e}}}}1 {ể}{{\h{\^{e}}}}1 {ễ}{{\~{\^{e}}}}1 {ệ}{{\d{\^{e}}}}1
        {í}{{\'{i}}}1 {ì}{{\`{i}}}1 {ỉ}{{\h{i}}}1 {ĩ}{{\~{i}}}1 {ị}{{\d{i}}}1
        {ó}{{\'{o}}}1 {ò}{{\`{o}}}1 {ỏ}{{\h{o}}}1 {õ}{{\~{o}}}1 {ọ}{{\d{o}}}1
        {ô}{{\^{o}}}1 {ố}{{\'{\^{o}}}}1 {ồ}{{\`{\^{o}}}}1 {ổ}{{\h{\^{o}}}}1 {ỗ}{{\~{\^{o}}}}1 {ộ}{{\d{\^{o}}}}1
        {ơ}{{\horn{o}}}1 {ớ}{{\'{\horn{o}}}}1 {ờ}{{\`{\horn{o}}}}1 {ở}{{\h{\horn{o}}}}1 {ỡ}{{\~{\horn{o}}}}1 {ợ}{{\d{\horn{o}}}}1
        {ú}{{\'{u}}}1 {ù}{{\`{u}}}1 {ủ}{{\h{u}}}1 {ũ}{{\~{u}}}1 {ụ}{{\d{u}}}1
        {ư}{{\horn{u}}}1 {ứ}{{\'{\horn{u}}}}1 {ừ}{{\`{\horn{u}}}}1 {ử}{{\h{\horn{u}}}}1 {ữ}{{\~{\horn{u}}}}1 {ự}{{\d{\horn{u}}}}1
        {ý}{{\'{y}}}1 {ỳ}{{\`{y}}}1 {ỷ}{{\h{y}}}1 {ỹ}{{\~{y}}}1 {ỵ}{{\d{y}}}1
        {đ}{{\dj}}1 {Đ}{{\DJ}}1
}
\lstset{style=cstyle}

% ============================================================================
% Header/Footer
% ============================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small MLFQ Scheduler cho xv6}
\fancyhead[R]{\small Hệ Điều Hành}
\fancyfoot[C]{\thepage}

% ============================================================================
% Title page
% ============================================================================
\begin{document}

\begin{titlepage}
\centering

\textbf{\large TRƯỜNG ĐẠI HỌC KHOA HỌC TỰ NHIÊN}\\
\textbf{\large KHOA CÔNG NGHỆ THÔNG TIN}\\[0.5cm]

\includegraphics[width=0.3\textwidth]{hcmus-logo.png}\\[1cm]
\vspace{2cm}

\vspace{1cm}
\rule{\textwidth}{1pt}\\[0.5cm]
{\Huge \textbf{Multi-Level Feedback Queue (MLFQ)\\Scheduler cho xv6}}\\[0.3cm]
\rule{\textwidth}{1pt}\\[1cm]

{\Large Đồ án môn học: \textbf{Hệ Điều Hành}}\\[2cm]

\begin{tabular}{ll}
\textbf{Sinh viên thực hiện:} & Lê Xuân Trí -- 23120099 \\
                               & Trần Hữu Kim Thành -- 23120166 \\
                               & Nguyễn Hồ Anh Tuấn -- 23120185 \\[0.5cm]
\textbf{Giảng viên hướng dẫn:} & Lê Giang Thanh\\
\end{tabular}

\vfill
{\large TP. Hồ Chí Minh, 2025}

\end{titlepage}

\newpage
\tableofcontents
\newpage

% ============================================================================
% 1. GIỚI THIỆU
% ============================================================================
\section{Giới thiệu}

\subsection{Bối cảnh}

Trong các hệ điều hành đa nhiệm, \textbf{CPU Scheduler} (bộ lập lịch CPU) đóng vai trò then chốt trong việc quyết định tiến trình nào được sử dụng CPU tại mỗi thời điểm. Một bộ lập lịch tốt cần đảm bảo sự công bằng giữa các tiến trình, tối ưu thời gian phản hồi (response time) cho tiến trình tương tác, và tận dụng hiệu quả tài nguyên hệ thống.

Hệ điều hành xv6 là một hệ điều hành giáo dục được phát triển bởi MIT, mô phỏng Unix trên nền tảng RISC-V. xv6 sử dụng thuật toán lập lịch \textbf{Round-Robin (RR)} đơn giản -- tất cả tiến trình được xử lý luân phiên với cùng một time quantum cố định. Tuy đơn giản và dễ hiểu, RR trong xv6 có những hạn chế rõ ràng:

\begin{itemize}
    \item \textbf{Không phân biệt CPU-bound và I/O-bound:} Mọi tiến trình đều được đối xử như nhau, bất kể hành vi sử dụng CPU.
    \item \textbf{Độ phản hồi kém cho tiến trình tương tác:} Tiến trình I/O-bound (thường cần phản hồi nhanh) phải chờ lượt như tiến trình CPU-bound.
    \item \textbf{Không thích nghi với hành vi runtime:} Không có cơ chế điều chỉnh ưu tiên dựa trên hành vi thực tế của tiến trình.
\end{itemize}

\subsection{Động lực nghiên cứu}

Xuất phát từ những hạn chế trên, nhóm đặt ra nhu cầu cải thiện:

\begin{itemize}
    \item \textbf{Tính công bằng:} Đảm bảo mọi tiến trình đều được phục vụ, không bị starvation.
    \item \textbf{Độ phản hồi (responsiveness):} Tiến trình tương tác/I/O-bound cần được ưu tiên để phản hồi nhanh.
    \item \textbf{Hiệu suất hệ thống:} Tận dụng CPU hiệu quả hơn bằng cách phân biệt các loại workload.
\end{itemize}

\textbf{Multi-Level Feedback Queue (MLFQ)} là giải pháp lập lịch được sử dụng rộng rãi trong các hệ điều hành hiện đại (Windows, macOS, Linux ở mức nguyên lý). MLFQ kết hợp nhiều hàng đợi ưu tiên với cơ chế feedback tự động, cho phép hệ thống tự điều chỉnh ưu tiên dựa trên hành vi thực tế của tiến trình.

\subsection{Mục tiêu đề tài}

\begin{enumerate}
    \item Thiết kế và triển khai \textbf{MLFQ Scheduler} thay thế Round-Robin trong kernel xv6 (RISC-V).
    \item Xây dựng các system call mới (\texttt{getpinfo}, \texttt{setpriority}) để truy xuất và điều khiển thông tin scheduler.
    \item Phát triển các chương trình test user-space để kiểm chứng hành vi MLFQ.
    \item Xây dựng giao diện visualization (terminal-based) để minh họa hoạt động lập lịch.
    \item So sánh và đánh giá hiệu năng giữa MLFQ và Round-Robin gốc.
\end{enumerate}

% ============================================================================
% 2. KIẾN THỨC NỀN TẢNG
% ============================================================================
\section{Kiến thức nền tảng}

\subsection{Tổng quan về CPU Scheduling}

CPU Scheduling (điều phối tiến trình) là quá trình hệ điều hành lựa chọn tiến trình nào trong Ready Queue sẽ được giao CPU để thực thi. Các mục tiêu chính của CPU scheduling bao gồm:

\begin{itemize}
    \item \textbf{Throughput:} Số lượng tiến trình hoàn thành trong một đơn vị thời gian.
    \item \textbf{Turnaround time:} Tổng thời gian từ khi tiến trình đến hệ thống đến khi hoàn thành ($T_{complete} - T_{arrive}$).
    \item \textbf{Waiting time:} Tổng thời gian tiến trình chờ trong Ready Queue.
    \item \textbf{Response time:} Thời gian từ khi tiến trình đến đến khi được CPU phục vụ lần đầu.
\end{itemize}

Các thuật toán lập lịch phổ biến:

\subsubsection{First-Come First-Served (FCFS)}
Tiến trình được phục vụ theo thứ tự đến. Là thuật toán đơn giản nhất, sử dụng điều phối \textbf{không độc quyền} (non-preemptive). Nhược điểm chính là hiện tượng \textit{convoy effect} -- tiến trình ngắn phải chờ tiến trình dài chạy xong, dẫn đến thời gian chờ trung bình cao.

\subsubsection{Shortest Job First (SJF)}
Tiến trình có CPU burst ngắn nhất được ưu tiên chạy trước. SJF tối ưu thời gian chờ trung bình, nhưng khó áp dụng thực tế vì không biết trước CPU burst. Có thể cài đặt độc quyền (SRTF) hoặc không độc quyền. Vấn đề starvation có thể xảy ra với tiến trình dài.

\subsubsection{Priority Scheduling}
Mỗi tiến trình được gán một giá trị ưu tiên (integer). Tiến trình có ưu tiên cao nhất được chọn chạy. Có hai loại:
\begin{itemize}
    \item \textbf{Ưu tiên tĩnh:} Ưu tiên được gán cố định, có nguy cơ starvation.
    \item \textbf{Ưu tiên động:} Ưu tiên thay đổi theo thời gian, giải quyết starvation bằng kỹ thuật \textit{aging}.
\end{itemize}

\subsubsection{Round-Robin (RR)}
Mỗi tiến trình chỉ sử dụng CPU trong một \textit{time quantum} (khoảng thời gian cố định $q$), sau đó bị preempt và đưa về cuối Ready Queue. RR là thuật toán điều phối \textbf{không độc quyền}, công bằng, phù hợp với hệ thống tương tác. Hiệu quả phụ thuộc vào giá trị $q$:
\begin{itemize}
    \item $q$ quá lớn $\Rightarrow$ thoái hóa thành FCFS.
    \item $q$ quá nhỏ $\Rightarrow$ overhead chuyển ngữ cảnh cao.
    \item Thông thường $q = 10$--$100$ milliseconds.
\end{itemize}

\subsection{Round-Robin Scheduler trong xv6}

Trong xv6 gốc, hàm \texttt{scheduler()} trong file \texttt{kernel/proc.c} thực hiện lập lịch Round-Robin đơn giản:

\begin{lstlisting}[caption={Scheduler RR gốc trong xv6 (đơn giản hóa)}]
void scheduler(void) {
  struct proc *p;
  struct cpu *c = mycpu();
  c->proc = 0;
  for(;;) {
    intr_on();
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context);
        c->proc = 0;
      }
      release(&p->lock);
    }
  }
}
\end{lstlisting}

\textbf{Đặc điểm:}
\begin{itemize}
    \item Duyệt tuần tự qua bảng tiến trình (\texttt{proc[NPROC]}).
    \item Chọn tiến trình \texttt{RUNNABLE} đầu tiên tìm được.
    \item Mỗi tiến trình chạy đúng 1 tick (timer interrupt) rồi bị preempt qua \texttt{yield()}.
    \item Không có khái niệm ưu tiên hay phân biệt workload.
\end{itemize}

\subsection{Multi-Level Feedback Queue (MLFQ) Scheduling}

MLFQ là thuật toán lập lịch kết hợp nhiều hàng đợi ưu tiên với cơ chế feedback tự động. Ý tưởng cốt lõi: \textit{học hành vi của tiến trình qua quan sát} -- thay vì yêu cầu thông tin trước về CPU burst, MLFQ điều chỉnh ưu tiên dựa trên hành vi thực tế.

\textbf{Các quy tắc kinh điển của MLFQ:}

\begin{enumerate}
    \item \textbf{Rule 1:} Nếu $Priority(A) > Priority(B)$, thì A chạy trước B.
    \item \textbf{Rule 2:} Nếu $Priority(A) = Priority(B)$, thì A và B chạy Round-Robin.
    \item \textbf{Rule 3:} Khi tiến trình mới vào hệ thống, nó được đặt ở hàng đợi ưu tiên cao nhất.
    \item \textbf{Rule 4:} Nếu tiến trình dùng hết time quantum tại mức ưu tiên hiện tại, ưu tiên của nó bị hạ xuống (demote).
    \item \textbf{Rule 5:} Sau một khoảng thời gian $S$ (boost interval), tất cả tiến trình được đưa về hàng đợi ưu tiên cao nhất (priority boost).
\end{enumerate}

\textbf{Ưu điểm của MLFQ:}
\begin{itemize}
    \item Tự động phân biệt CPU-bound và I/O-bound.
    \item Tiến trình I/O-bound (tương tác) được ưu tiên, cải thiện response time.
    \item Tiến trình CPU-bound vẫn được phục vụ nhờ priority boost.
    \item Không cần biết trước thông tin về tiến trình.
\end{itemize}

% ============================================================================
% 3. THIẾT KẾ HỆ THỐNG
% ============================================================================
\section{Thiết kế hệ thống}

\subsection{Kiến trúc tổng thể}

MLFQ Scheduler được tích hợp trực tiếp vào kernel xv6, thay thế cơ chế Round-Robin gốc. Kiến trúc tổng thể bao gồm:

\begin{itemize}
    \item \textbf{Scheduler core} (\texttt{proc.c}): Vòng lặp scheduler chọn tiến trình theo thứ tự ưu tiên.
    \item \textbf{Timer interrupt handler} (\texttt{trap.c}): Khi timer interrupt xảy ra, gọi \texttt{yield()} để cập nhật tick và kiểm tra quantum.
    \item \textbf{Feedback mechanism}: Tích hợp trong \texttt{yield()}, \texttt{sleep()}, và \texttt{wakeup()} -- quyết định demote/keep/boost priority.
    \item \textbf{System calls}: \texttt{getpinfo()} và \texttt{setpriority()} cho phép user-space truy xuất thông tin scheduler.
\end{itemize}

Tương tác giữa các thành phần:

\begin{verbatim}
Timer Interrupt --> usertrap()/kerneltrap() --> yield()
                                                  |
                                          Cập nhật ticks
                                          Kiểm tra quantum
                                          Demote nếu cần
                                                  |
                                          scheduler() <--+
                                                  |      |
                                          Chọn process   |
                                          ưu tiên cao    |
                                          nhất (MLFQ)    |
                                                  |      |
                                          swtch()--------+
\end{verbatim}

\subsection{Thiết kế hàng đợi (Queue Design)}

Hệ thống sử dụng \textbf{3 hàng đợi} ưu tiên (định nghĩa bởi \texttt{NMLFQ = 3} trong \texttt{param.h}):

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
\textbf{Queue} & \textbf{Ưu tiên} & \textbf{Time Quantum} & \textbf{Mô tả} \\
\hline
Queue 0 & Cao nhất & 1 tick (\texttt{MLFQ\_TICKS\_0}) & Tiến trình mới / I/O-bound \\
Queue 1 & Trung bình & 2 ticks (\texttt{MLFQ\_TICKS\_1}) & Tiến trình dùng hết quantum Q0 \\
Queue 2 & Thấp nhất & 4 ticks (\texttt{MLFQ\_TICKS\_2}) & Tiến trình CPU-bound \\
\hline
\end{tabular}
\caption{Cấu hình 3 hàng đợi MLFQ}
\end{table}

\textbf{Chính sách chọn queue:}
\begin{itemize}
    \item Scheduler duyệt từ Queue 0 đến Queue 2.
    \item Chọn tiến trình \texttt{RUNNABLE} đầu tiên ở queue có ưu tiên cao nhất.
    \item Trong cùng queue, áp dụng Round-Robin (duyệt tuần tự qua bảng \texttt{proc[]}).
\end{itemize}

\subsection{Cấu trúc dữ liệu}

\subsubsection{Mở rộng \texttt{struct proc}}

Cấu trúc \texttt{struct proc} (trong \texttt{kernel/proc.h}) được mở rộng với các trường MLFQ:

\begin{lstlisting}[caption={Các trường MLFQ trong struct proc}]
// Các trường MLFQ scheduler
int priority;         // Hàng đợi ưu tiên hiện tại (0=cao nhất, NMLFQ-1=thấp nhất)
int ticks_used;       // Số ticks đã dùng trong time slice hiện tại
int ticks_total;      // Tổng số ticks đã dùng (thống kê)
uint64 last_run_time; // Thời điểm tiến trình được lập lịch lần cuối
\end{lstlisting}

\subsubsection{Biến toàn cục MLFQ}

\begin{lstlisting}[caption={Biến toàn cục MLFQ trong proc.c}]
// Trạng thái toàn cục MLFQ
uint64 mlfq_ticks = 0;       // Bộ đếm tick toàn cục cho priority boost
struct spinlock mlfq_lock;   // Lock bảo vệ trạng thái MLFQ
\end{lstlisting}

\textbf{Ghi chú về cách tổ chức queue:} Thay vì dùng danh sách liên kết riêng cho từng queue, thiết kế sử dụng trường \texttt{priority} trong mỗi \texttt{struct proc} để xác định queue. Scheduler duyệt bảng \texttt{proc[NPROC]} và lọc theo priority. Cách tiếp cận này đơn giản, phù hợp với quy mô nhỏ của xv6 (\texttt{NPROC = 64}).

\subsection{Cơ chế Feedback}

\subsubsection{Hạ ưu tiên (Demotion)}

Khi tiến trình dùng hết time quantum tại mức ưu tiên hiện tại, nó bị demote xuống queue thấp hơn. Logic nằm trong hàm \texttt{yield()}:

\begin{lstlisting}[caption={Logic demotion trong yield()}]
// Nhường CPU cho một vòng lập lịch.
// MLFQ: Cập nhật ticks và hạ ưu tiên nếu hết time slice
void yield(void) {
  struct proc *p = myproc();
  acquire(&p->lock);
  
  // Cập nhật bộ đếm ticks MLFQ
  p->ticks_used++;
  p->ticks_total++;
  
  // Cập nhật bộ đếm tick toàn cục cho priority boost
  acquire(&mlfq_lock);
  mlfq_ticks++;
  release(&mlfq_lock);
  
  // Kiểm tra tiến trình đã dùng hết time slice chưa
  int time_slice = get_time_slice(p->priority);
  if(p->ticks_used >= time_slice) {
    // Hạ xuống queue ưu tiên thấp hơn (nếu chưa ở thấp nhất)
    if(p->priority < NMLFQ - 1) {
      p->priority++;
    }
    p->ticks_used = 0;  // Reset ticks cho mức ưu tiên mới
  }
  
  p->state = RUNNABLE;
  sched();
  release(&p->lock);
}
\end{lstlisting}

\subsubsection{Giữ/Tăng ưu tiên}

Tiến trình yield sớm (trước khi hết quantum) -- thường do I/O -- không bị demote. Trong hàm \texttt{sleep()}, \texttt{ticks\_used} được reset:

\begin{lstlisting}[caption={Reset ticks khi sleep (I/O behavior)}]
// Giải phóng lock và sleep trên channel.
// MLFQ: Tiến trình đi sleep thường là I/O-bound, reset ticks
void sleep(void *chan, struct spinlock *lk) {
  struct proc *p = myproc();
  
  acquire(&p->lock);  //DOC: sleeplock1
  release(lk);

  // MLFQ: Tiến trình tự nguyện nhường CPU trước khi hết time slice
  // Điều này cho thấy hành vi I/O-bound, nên reset ticks (không bị demote)
  p->ticks_used = 0;

  // Đi vào trạng thái ngủ
  p->chan = chan;
  p->state = SLEEPING;
  sched();
  // ... (dọn dẹp và lấy lại lock ban đầu)
}
\end{lstlisting}

Khi tiến trình I/O-bound wake up, nó được boost lên 1 mức ưu tiên (trong hàm \texttt{wakeup()}):

\begin{lstlisting}[caption={Priority boost khi wakeup}]
// Đánh thức tất cả tiến trình đang sleep trên channel.
// MLFQ: Tăng ưu tiên cho tiến trình I/O-bound khi thức dậy
void wakeup(void *chan) {
  struct proc *p;
  for(p = proc; p < &proc[NPROC]; p++) {
    if(p != myproc()){
      acquire(&p->lock);
      if(p->state == SLEEPING && p->chan == chan) {
        p->state = RUNNABLE;
        // MLFQ: Tiến trình I/O-bound được tăng ưu tiên khi thức dậy
        // Tăng lên một mức ưu tiên (nếu chưa ở cao nhất)
        if(p->priority > 0) {
          p->priority--;
        }
      }
      release(&p->lock);
    }
  }
}
\end{lstlisting}

\subsection{Xử lý Starvation}

\textbf{Vấn đề:} Trong hệ thống có nhiều tiến trình I/O-bound ở queue cao, tiến trình CPU-bound ở queue thấp có thể không bao giờ được chạy (starvation).

\textbf{Giải pháp -- Priority Boost:} Sau mỗi \texttt{BOOST\_INTERVAL = 100} ticks, tất cả tiến trình được đưa về Queue 0 (ưu tiên cao nhất) và reset \texttt{ticks\_used}:

\begin{lstlisting}[caption={Cơ chế Priority Boost}]
// Priority boost: đưa tất cả tiến trình về queue ưu tiên cao nhất
// Được gọi định kỳ để chống starvation
static void priority_boost(void) {
  struct proc *p;
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state != UNUSED) {
      p->priority = 0;     // Đưa về queue cao nhất
      p->ticks_used = 0;   // Reset ticks
    }
    release(&p->lock);
  }
}
\end{lstlisting}

Priority boost được kiểm tra ở đầu mỗi vòng lặp scheduler:

\begin{lstlisting}[caption={Kiểm tra priority boost trong scheduler()}]
// Kiểm tra priority boost
acquire(&mlfq_lock);
if(mlfq_ticks >= BOOST_INTERVAL) {
  mlfq_ticks = 0;
  release(&mlfq_lock);
  priority_boost();
} else {
  release(&mlfq_lock);
}
\end{lstlisting}

% ============================================================================
% 4. TRIỂN KHAI
% ============================================================================
\section{Triển khai}

\subsection{Các file kernel đã chỉnh sửa}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{File} & \textbf{Nội dung thay đổi} \\
\hline
\texttt{kernel/param.h} & Thêm hằng số: \texttt{NMLFQ}, \texttt{MLFQ\_TICKS\_0/1/2}, \texttt{BOOST\_INTERVAL} \\
\hline
\texttt{kernel/proc.h} & Mở rộng \texttt{struct proc} với 4 trường MLFQ \\
\hline
\texttt{kernel/proc.c} & Viết lại \texttt{scheduler()}, cập nhật \texttt{yield()}, \texttt{sleep()}, \texttt{wakeup()}, \texttt{allocproc()}, \texttt{freeproc()}. Thêm \texttt{priority\_boost()}, \texttt{get\_time\_slice()}, \texttt{getprocinfo()}, \texttt{setprocpriority()} \\
\hline
\texttt{kernel/trap.c} & Không thay đổi logic -- timer interrupt vẫn gọi \texttt{yield()}, nhưng \texttt{yield()} đã được sửa đổi \\
\hline
\texttt{kernel/syscall.h} & Thêm \texttt{SYS\_getpinfo} (22), \texttt{SYS\_setpriority} (23) \\
\hline
\texttt{kernel/syscall.c} & Đăng ký 2 syscall mới vào bảng \texttt{syscalls[]} \\
\hline
\texttt{kernel/sysproc.c} & Thêm \texttt{sys\_getpinfo()}, \texttt{sys\_setpriority()} \\
\hline
\texttt{kernel/defs.h} & Khai báo prototype cho \texttt{getprocinfo()}, \texttt{setprocpriority()} \\
\hline
\texttt{kernel/pstat.h} & Header định nghĩa cấu trúc dữ liệu cho process info \\
\hline
\texttt{user/user.h} & Thêm prototype \texttt{getpinfo()}, \texttt{setpriority()} \\
\hline
\texttt{user/usys.pl} & Thêm entry cho 2 syscall mới \\
\hline
\end{tabular}
\caption{Danh sách file đã chỉnh sửa}
\end{table}

\subsection{Cài đặt MLFQ Scheduler}

\subsubsection{Hàm \texttt{scheduler()} -- Luồng chính}

Hàm \texttt{scheduler()} được viết lại hoàn toàn. Thay vì duyệt đơn giản qua bảng tiến trình, scheduler mới:

\begin{enumerate}
    \item Kiểm tra priority boost (nếu đủ \texttt{BOOST\_INTERVAL} ticks).
    \item Duyệt từ queue 0 (cao nhất) đến queue \texttt{NMLFQ-1} (thấp nhất).
    \item Tại mỗi queue, tìm tiến trình \texttt{RUNNABLE} đầu tiên.
    \item Nếu tìm thấy, chuyển sang tiến trình đó (\texttt{swtch()}).
\end{enumerate}

\begin{lstlisting}[caption={Hàm scheduler() mới với MLFQ}]
void scheduler(void) {
  struct proc *p;
  struct cpu *c = mycpu();
  int priority;
  struct proc *selected;

  c->proc = 0;
  for(;;){
    intr_on();

    // Kiểm tra priority boost
    acquire(&mlfq_lock);
    if(mlfq_ticks >= BOOST_INTERVAL) {
      mlfq_ticks = 0;
      release(&mlfq_lock);
      priority_boost();
    } else {
      release(&mlfq_lock);
    }

    // MLFQ: Tìm tiến trình runnable có ưu tiên cao nhất
    // Duyệt từ queue 0 (cao nhất) đến NMLFQ-1 (thấp nhất)
    selected = 0;
    for(priority = 0; priority < NMLFQ && selected == 0; priority++) {
      for(p = proc; p < &proc[NPROC]; p++) {
        acquire(&p->lock);
        if(p->state == RUNNABLE && p->priority == priority) {
          // Tìm thấy tiến trình runnable ở mức ưu tiên này
          selected = p;
          break;
        }
        release(&p->lock);
      }
    }

    if(selected) {
      // Chuyển sang tiến trình được chọn
      selected->state = RUNNING;
      c->proc = selected;
      swtch(&c->context, &selected->context);
      c->proc = 0;
      release(&selected->lock);
    }
  }
}
\end{lstlisting}

\subsubsection{Hàm \texttt{get\_time\_slice()} -- Quantum theo priority}

\begin{lstlisting}[caption={Time slice mapping}]
static int get_time_slice(int priority) {
  switch(priority) {
    case 0: return MLFQ_TICKS_0;  // 1 tick
    case 1: return MLFQ_TICKS_1;  // 2 ticks
    case 2: return MLFQ_TICKS_2;  // 4 ticks
    default: return MLFQ_TICKS_2;
  }
}
\end{lstlisting}

\subsection{System Calls mới}

\subsubsection{\texttt{getpinfo()} -- Lấy thông tin tiến trình}

System call \texttt{getpinfo()} cho phép user-space đọc thông tin MLFQ của tất cả tiến trình. Dữ liệu được copy vào buffer do user cung cấp, bao gồm: PID, priority, state, ticks\_used, ticks\_total, name.

Cấu trúc dữ liệu trả về cho mỗi tiến trình:
\begin{lstlisting}
struct {
  int inuse;          // Process đang được sử dụng?
  int pid;            // Process ID
  int priority;       // Queue hiện tại (0-2)
  int state;          // Trạng thái (RUNNABLE, RUNNING, SLEEPING,...)
  int ticks_used;     // Ticks đã dùng trong quantum hiện tại
  int ticks_total;    // Tổng ticks (thống kê)
  char name[16];      // Tên tiến trình
};
\end{lstlisting}

\subsubsection{\texttt{setpriority(pid, priority)} -- Đặt ưu tiên thủ công}

Cho phép user-space thay đổi priority của một tiến trình theo PID. Giá trị priority hợp lệ: 0 (cao), 1, 2 (thấp). Trả về 0 nếu thành công, -1 nếu thất bại.

\subsection{Priority Boost}

Priority boost được kích hoạt khi bộ đếm toàn cục \texttt{mlfq\_ticks} đạt \texttt{BOOST\_INTERVAL} (100 ticks). Tác động:
\begin{itemize}
    \item Tất cả tiến trình (trừ UNUSED) được đưa về Queue 0.
    \item \texttt{ticks\_used} được reset về 0.
    \item Bộ đếm \texttt{mlfq\_ticks} reset về 0.
\end{itemize}

Điều này đảm bảo:
\begin{itemize}
    \item Tiến trình CPU-bound ở queue thấp vẫn được cơ hội chạy (chống starvation).
    \item Hệ thống ``quên'' hành vi cũ, cho phép tái đánh giá tiến trình.
\end{itemize}

\subsection{Tính tương thích với xv6 gốc}

Thiết kế đảm bảo tương thích ngược:
\begin{itemize}
    \item Tất cả syscall gốc (\texttt{fork}, \texttt{exec}, \texttt{exit}, \texttt{wait},...) hoạt động bình thường.
    \item Chương trình user-space gốc không cần sửa đổi.
    \item Tiến trình mới luôn bắt đầu ở Queue 0 (ưu tiên cao nhất).
    \item Chỉ thêm 2 syscall mới, không thay đổi interface cũ.
\end{itemize}

% ============================================================================
% 5. GIAO DIỆN MINH HỌA (VISUALIZATION)
% ============================================================================
\section{Giao diện minh họa (Visualization)}

\subsection{Mục tiêu}

Xây dựng giao diện trực quan để minh họa hoạt động MLFQ scheduler trong thời gian thực, giúp:
\begin{itemize}
    \item Quan sát tiến trình đang chạy ở queue nào.
    \item Theo dõi quá trình demotion và priority boost.
    \item So sánh hành vi CPU-bound vs I/O-bound.
\end{itemize}

\subsection{Terminal-based Visualization (mlfqmon)}

Chương trình \texttt{mlfqmon} chạy bên trong xv6 (QEMU), sử dụng syscall \texttt{getpinfo()} để đọc thông tin scheduler và hiển thị dạng bảng cập nhật liên tục.

\textbf{Thông tin hiển thị:}
\begin{itemize}
    \item \textbf{Queue Status:} Số lượng tiến trình trong mỗi queue, kèm thanh tiến trình trực quan.
    \item \textbf{Process Table:} PID, Priority, State, Ticks Used, Ticks Total, Name cho mỗi tiến trình.
    \item \textbf{Tổng quan:} Tổng số tiến trình, số đang chạy, số đang sleep.
\end{itemize}

\begin{lstlisting}[caption={Ví dụ output của mlfqmon},language={}]
        MLFQ SCHEDULER MONITOR (Refresh #5)
Time: 234 ticks

QUEUE STATUS:
Queue 0 [HIGH  ] (3) [######              ]
Queue 1 [MEDIUM] (1) [====                ]
Queue 2 [LOW   ] (2) [--------            ]
------------------------------------------------------------

PROCESS TABLE:
PID   PRIO  STATE   TICKS   TOTAL   NAME
------------------------------------------------------------
1     0     SLEEP   0       12      init
2     0     SLEEP   0       8       sh
*5    0     RUN     0       45      io_bound*
6     1     RUNBLE  1       89      cpu_bound
7     2     RUNBLE  3       156     cpu_bound
Total: 5 | Running: 1 | Sleeping: 2
\end{lstlisting}

\subsection{Terminal-based UI}

Hình \ref{fig:mlfqmon} minh họa giao diện terminal-based của chương trình \texttt{monitor} (phiên bản nâng cao của \texttt{mlfqmon}) với hỗ trợ ANSI colors, cung cấp cái nhìn trực quan về trạng thái scheduler.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{mlfqmon.jpg}
    \caption{Giao diện MLFQ Scheduler Monitor v1.0}
    \label{fig:mlfqmon}
\end{figure}

\textbf{Giải thích các thành phần:}
\begin{itemize}
    \item \textbf{Header:} Hiển thị tên ứng dụng, System Time (tổng số ticks), và Refresh counter.
    \item \textbf{Queue Visualization:} Biểu diễn trực quan 3 hàng đợi (Q0-HIGH, Q1-MEDIUM, Q2-LOW) với thanh progress bar và time slice tương ứng (1, 2, 4 ticks).
    \item \textbf{System Stats:} Thống kê tổng số tiến trình, số đang Running, Sleeping, Runnable, và thời gian còn lại đến Next Boost.
    \item \textbf{Process Table:} Chi tiết từng tiến trình gồm PID, NAME, STATE, PRIO (priority), SLICE (time slice progress), TOTAL (tổng ticks), SCHED (số lần scheduled), DEM (demotions), BST (boosts).
    \item \textbf{Legend:} Giải thích màu sắc và ký hiệu (* = đang chạy, màu xanh lá = HIGH, vàng = MED, đỏ = LOW).
\end{itemize}


% ============================================================================
% 6. ĐÁNH GIÁ VÀ THỰC NGHIỆM
% ============================================================================
\section{Đánh giá và thực nghiệm}

\subsection{Môi trường thử nghiệm}

\begin{itemize}
    \item \textbf{Giả lập:} QEMU (qemu-system-riscv64)
    \item \textbf{Hệ điều hành:} xv6-riscv (phiên bản chỉnh sửa MLFQ)
    \item \textbf{CPU:} 1 CPU (đơn lõi) trong QEMU
    \item \textbf{Toolchain:} riscv64-unknown-elf-gcc
\end{itemize}

\subsection{Kịch bản thử nghiệm}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{5cm}|p{6cm}|}
\hline
\textbf{Kịch bản} & \textbf{Mô tả} & \textbf{Kết quả mong đợi} \\
\hline
CPU-bound & 2 tiến trình tính toán nặng & Bị demote xuống Queue 2, quantum 4 ticks \\
\hline
I/O-bound & 2 tiến trình sleep thường xuyên & Giữ ở Queue 0, quantum 1 tick, phản hồi nhanh \\
\hline
Mixed & 2 CPU-bound + 2 I/O-bound & CPU-bound demote, I/O-bound giữ ưu tiên cao \\
\hline
Priority Boost & Chạy CPU-bound lâu dài & Sau 100 ticks, tất cả về Queue 0 \\
\hline
\end{tabular}
\caption{Các kịch bản thử nghiệm}
\end{table}

\textbf{Các chương trình test:}
\begin{itemize}
    \item \texttt{cpu\_bound}: Tiến trình tính toán nặng, thử cơ chế demotion.
    \item \texttt{io\_bound}: Tiến trình sleep thường xuyên, thử khả năng giữ ưu tiên cao.
    \item \texttt{schedtest}: Test tổng hợp mixed workload.
    \item \texttt{mlfqmon}: Monitor hiển thị trạng thái scheduler theo thời gian thực.
    \item \texttt{monitor}: TUI monitor nâng cao với ANSI colors.
    \item \texttt{mlfq\_test}: Bộ test MLFQ toàn diện với nhiều test case.
    \item \texttt{test\_pstat}: Test cho syscall \texttt{getpinfo()}.
\end{itemize}

\subsection{Chỉ số đánh giá}

\begin{itemize}
    \item \textbf{Response time:} Đo bằng thời gian từ khi tiến trình sẵn sàng đến khi được CPU lần đầu. I/O-bound processes trong MLFQ có response time thấp hơn đáng kể so với RR.
    \item \textbf{Turnaround time:} Tổng thời gian hoàn thành. I/O-bound processes hoàn thành nhanh hơn trong MLFQ nhờ được ưu tiên.
    \item \textbf{Fairness:} Priority boost đảm bảo không có tiến trình bị starvation.
\end{itemize}

\subsection{Kết quả}

Kết quả thực nghiệm với chương trình \texttt{schedtest} (2 CPU-bound + 2 I/O-bound):

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Chỉ số} & \textbf{Round-Robin (gốc)} & \textbf{MLFQ} \\
\hline
I/O-bound response time & Trung bình & Thấp (ưu tiên cao) \\
\hline
CPU-bound throughput & Đồng đều & Vẫn đảm bảo (quantum dài hơn ở Q2) \\
\hline
Starvation & Không & Không (nhờ priority boost) \\
\hline
Phân biệt workload & Không & Tự động \\
\hline
\end{tabular}
\caption{So sánh Round-Robin và MLFQ}
\end{table}

\textbf{Quan sát qua mlfqmon:}
\begin{itemize}
    \item Tiến trình CPU-bound (ví dụ: \texttt{cpu\_bound}) bắt đầu ở Queue 0, sau vài ticks bị demote xuống Queue 1, rồi Queue 2.
    \item Tiến trình I/O-bound (ví dụ: \texttt{io\_bound}) liên tục ở Queue 0 vì yield sớm khi sleep.
    \item Sau mỗi 100 ticks, priority boost đưa tất cả về Queue 0 -- quan sát được qua sự thay đổi đột ngột trong queue distribution.
    \item Tiến trình CPU-bound ở Queue 2 được time quantum dài hơn (4 ticks), giúp tận dụng CPU tốt hơn khi được chạy.
\end{itemize}

% ============================================================================
% 7. TỔNG KẾT
% ============================================================================
\section{Tổng kết}

\subsection{Những gì đã làm được}

\begin{enumerate}
    \item \textbf{MLFQ Scheduler hoàn chỉnh:} Thay thế Round-Robin bằng MLFQ 3 queue với time quantum tăng dần, cơ chế feedback tự động, và priority boost chống starvation.
    \item \textbf{System calls mới:} \texttt{getpinfo()} để đọc thông tin scheduler, \texttt{setpriority()} để điều khiển ưu tiên thủ công.
    \item \textbf{Bộ test đầy đủ:} 6 chương trình user-space (\texttt{cpu\_bound}, \texttt{io\_bound}, \texttt{schedtest}, \texttt{pstat}, \texttt{setpri}, \texttt{demo}) kiểm chứng mọi khía cạnh của MLFQ.
    \item \textbf{Visualization:} Terminal-based monitor (\texttt{mlfqmon}) hiển thị trạng thái scheduler real-time.
    \item \textbf{Tương thích ngược:} Không phá vỡ chức năng gốc của xv6.
\end{enumerate}

\subsection{Phạm vi và hạn chế}

\begin{itemize}
    \item \textbf{Đơn lõi:} Chỉ triển khai trên 1 CPU. Trên nhiều CPU, cần cơ chế load balancing giữa các queue.
    \item \textbf{Tham số cố định:} Time quantum và boost interval được hard-code. Hệ thống thực cần adaptive tuning.
    \item \textbf{Queue organization:} Không dùng danh sách liên kết riêng cho mỗi queue, mà duyệt toàn bộ bảng \texttt{proc[]} -- hiệu quả với \texttt{NPROC=64} nhưng không scale cho hệ thống lớn.
    \item \textbf{Scheduler overhead:} Duyệt $O(NMLFQ \times NPROC)$ mỗi lần lập lịch. Với NPROC nhỏ, overhead không đáng kể.
    \item \textbf{Gaming prevention:} Chưa xử lý trường hợp tiến trình cố tình yield ngay trước khi hết quantum để tránh bị demote.
\end{itemize}

\subsection{So sánh với CFS của Linux}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{5cm}|p{5cm}|}
\hline
\textbf{Tiêu chí} & \textbf{MLFQ (xv6)} & \textbf{Linux CFS} \\
\hline
Cách tiếp cận & Nhiều queue, feedback & Cây đỏ-đen, virtual runtime \\
\hline
Fairness & Priority boost & Proportional share \\
\hline
Starvation & Boost định kỳ & vruntime đảm bảo \\
\hline
Complexity & Đơn giản, dễ hiểu & Phức tạp, tối ưu cao \\
\hline
Multi-core & Chưa hỗ trợ & Load balancing tích hợp \\
\hline
\end{tabular}
\caption{So sánh MLFQ (xv6) và Linux CFS}
\end{table}

% ============================================================================
% 8. HƯỚNG PHÁT TRIỂN
% ============================================================================
\section{Hướng phát triển}

\begin{enumerate}
    \item \textbf{Adaptive quantum:} Tự động điều chỉnh time quantum dựa trên system load và hành vi tiến trình.
    \item \textbf{Multi-core support:} Mỗi CPU có queue riêng, thêm cơ chế work stealing/load balancing.
    \item \textbf{Gaming prevention:} Theo dõi tổng CPU time tại mỗi mức ưu tiên (accounting rule), demote khi tích lũy đủ.
    \item \textbf{Scheduler policy plugin:} Cho phép chuyển đổi giữa RR, MLFQ, và các thuật toán khác tại runtime.
    \item \textbf{Web-based UI:} Hoàn thiện giao diện web real-time (TUI với ANSI colors, biểu đồ timeline).
    \item \textbf{Benchmarking:} Xây dựng benchmark suite đầy đủ để đo lường chính xác response time, turnaround time, throughput.
\end{enumerate}

% ============================================================================
% 9. TÀI LIỆU THAM KHẢO
% ============================================================================
\section{Tài liệu tham khảo}

\begin{enumerate}
    \item Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau. \textit{Operating Systems: Three Easy Pieces (OSTEP)}. Chapter 8: Scheduling: The Multi-Level Feedback Queue. \url{https://pages.cs.wisc.edu/~remzi/OSTEP/}

    \item Russ Cox, Frans Kaashoek, Robert Morris. \textit{xv6: a simple, Unix-like teaching operating system}. MIT. \url{https://pdos.csail.mit.edu/6.S081/2024/xv6/book-riscv-rev4.pdf}

    \item MIT 6.S081: Operating System Engineering. \url{https://pdos.csail.mit.edu/6.S081/}

    \item Abraham Silberschatz, Peter B. Galvin, Greg Gagne. \textit{Operating System Concepts} (10th Edition). Chapter 5: CPU Scheduling.

    \item Andrew S. Tanenbaum, Herbert Bos. \textit{Modern Operating Systems} (4th Edition). Chapter 2: Processes and Threads.

    \item Bài giảng ``Quản lý tiến trình'' -- Môn Hệ Điều Hành, Khoa CNTT, Trường ĐH KHTN TP.HCM.
\end{enumerate}

% ============================================================================
% 10. LINK VIDEO DEMO
% ============================================================================
\section{Link Video Demo}

\textit{(Thêm link video demo tại đây)}

% Video demo trình bày:
% - Build và chạy xv6 với MLFQ scheduler
% - Chạy cpu_bound, io_bound, và quan sát demotion
% - Chạy schedtest với mixed workload
% - Sử dụng mlfqmon để quan sát real-time
% - Sử dụng pstat để xem thống kê
% - Minh họa priority boost

\end{document}
